spring:
  application:
    name: shardingsphere-jdbc
server:
  port: 9090

# 数据源配置，可配置多个data_source_name
dataSources:
  # ds0为“data_source_name” 即数据库名，需自定义。 冒号后为数据连接池实现类  !!表示实例化该类
  ds0: !!com.alibaba.druid.pool.DruidDataSource
    # 数据库驱动类名
    driverClassName: com.mysql.jdbc.Driver
    # 数据库url连接
    url: jdbc:mysql://localhost:3306/ds0
    # 数据库用户名
    username: root
    # 数据库密码
    password: root
  ds1: !!com.alibaba.druid.pool.DruidDataSource
    driverClassName: com.mysql.jdbc.Driver
    url: jdbc:mysql://localhost:3306/ds1
    username: root
    password: root

shardingRule:
  # 数据分片规则配置，可配置多个logic_table_name，即逻辑表名称，比如  user1，user2
  tables:
    # 逻辑表名称，需自定义
    t_order:
      # 由数据源名 + 表名组成，以小数点分隔。多个表以逗号分隔
      actualDataNodes: ds${0..1}.t_order${0..1}
      # databaseStrategy-分库策略，缺省表示使用默认分库策略，以下的分片策略只能选其一
      # 1.standard-用于单分片键的标准分片场景
      #      shardingColumn: 分片列名称
      #      preciseAlgorithmClassName: 精确分片算法类名称，用于=和IN。。该类需实现PreciseShardingAlgorithm接口并提供无参数的构造器
      #      rangeAlgorithmClassName: 范围分片算法类名称，用于BETWEEN，可选。。该类需实现RangeShardingAlgorithm接口并提供无参数的构造器
      # 2.complex-用于多分片键的复合分片场景
      #      shardingColumns: #分片列名称，多个列以逗号分隔
      #      algorithmClassName: #复合分片算法类名称。该类需实现ComplexKeysShardingAlgorithm接口并提供无参数的构造器
      # 3.inline-行表达式分片策略
      #     shardingColumn: #分片列名称
      #     algorithmInlineExpression: #分片算法行表达式，需符合groovy语法
      # 4.hint-Hint分片策略
      #     algorithmClassName: #Hint分片算法类名称。该类需实现HintShardingAlgorithm接口并提供无参数的构造器
      # 5.none-不分片
      databaseStrategy:
        inline:
          shardingColumn: user_id
          algorithmExpression: ds${user_id % 2}
      # 分表策略，同分库策略databaseStrategy
      tableStrategy:
        inline:
          shardingColumn: order_id
          algorithmExpression: t_order${order_id % 2}
      keyGenerator:
        # 自增列名称，缺省表示不使用自增主键生成器
        column: order_id
        # 自增列值生成器类型，缺省表示使用默认自增列值生成器。
        # 可使用用户自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID
        type: SNOWFLAKE
    #  props: 属性配置, 注意：使用SNOWFLAKE算法，需要配置worker.id与max.tolerate.time.difference.milliseconds属性。
    #  若使用此算法生成值作分片值，建议配置max.vibration.offset属性
    #     <property-name>: 属性名称

    # 逻辑表名称，需自定义  和上方t_order一样
    t_order_item:
      actualDataNodes: ds${0..1}.t_order_item${0..1}
      databaseStrategy:
        inline:
          shardingColumn: user_id
          algorithmExpression: ds${user_id % 2}
      tableStrategy:
        inline:
          shardingColumn: order_id
          algorithmExpression: t_order_item${order_id % 2}
  # 绑定表规则列表
  bindingTables:
    - t_order,t_order_item
  # 广播表规则列表
  broadcastTables:
    - t_config

  # 未配置分片规则的表将通过默认数据源定位
  defaultDataSourceName: ds0
  # 默认数据库分片策略，同分库策略
  defaultTableStrategy:
    none:
  # 默认的主键生成算法 如果没有设置,默认为SNOWFLAKE算法
  defaultKeyGenerator:
    # 默认自增列值生成器类型，缺省将使用org.apache.shardingsphere.core.keygen.generator.impl.SnowflakeKeyGenerator。
    # 可使用用户自定义的列值生成器或选择内置类型：SNOWFLAKE/UUID
    type: SNOWFLAKE
    column: order_id

props:
  sql.show: true